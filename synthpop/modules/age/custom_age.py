""" This is an example on how to create your own age module
You have to follow this 4 steps:

1. Import the Parent Class
2. Create a subclass
3. Include all parameters as attribute in the __init__ function.
4. Define all Abstract Functions from the Parent Class

"""

# provide information on the name of the class
__all__ = ['CustomAge', ]

import numpy as np
# Import the ParentClass should work with all three cases, but from ._age is preferred.
from ._age import Age


# from _age import Age
# from synthpop.modules.age import Age


# create a subclass of the ParentClass
class CustomAge(Age):
    """
    Custom Age subclass template for Age base class. This subclass is for
    Populations that have ages characterized by a uniform distribution 
    between two bounds. 

    Currently, this is a copy of the Uniform subclass. If you would like to
    make this a permanent subclass, please 
    1. Define a unique subclass name.
    2. Define a unique subclass attribute age_func_name.
    3. Update population_parameter.json files that reference this subclass.

    Attributes
    ----------
    age_func_name : string
        A class attribute for the name of the Age base subclass that this is.
    low_bound : float [Gyr]
        The lower bound of the uniform age distribution in Giga-years.
    high_bound : float [Gyr]
        The upper bound of the uniform age distribution in Giga-years.
    
    Methods
    -------
    __init__(self,Population) : None
        check that required attributes of Population are present:
            -Population.age_value : float
    random_age(self) : float, ndarray [Gyr]
        return a random age from uniform distribution [low_bound, high_bound]
    average_age(self) : float [Gyr]
        return the average age, (low_bound+high_bound)/2.0
    """

    # all parameters of the distribution should be an argument
    # in the attribute of the __init__, name and filename are forbidden arguments,
    # They are used to find the Subclass and are not passed to the initialization.

    def __init__(self, low_bound, high_bound, **kwargs):
        super().__init__(**kwargs)
        self.age_func_name = 'Custom_age'
        self.low_bound = low_bound
        self.high_bound = high_bound

    # define at least all Abstract function from the ParentClass.
    # you MUST use the footprint from the corresponding function.
    def draw_random_age(self, N=None):
        """
        Generate a random age from distribution

        Parameters
        ----------
        N : int, None, optional
            if N is set to an integer, an array with N random ages is returned

        Returns
        -------
        age : float, ndarray [Gyr]
            single age or numpy array of N ages in Giga-years
        """
        return np.random.uniform(self.low_bound, self.high_bound, N)

    def average_age(self):
        """Determine the average age of the population"""
        return (self.low_bound + self.high_bound) / 2.0

    def get_maximum_age(self) -> float:
        """
        returns the maximum age generated by the distribution
        """
        return self.high_bound
